module Language.Pepa.Ode.RateEquations
    ( toRateEqnModel
    , formatForDizzy
    )
where
{- Standard Library Modules Imported -}
import Data.List
    ( nub )
import Data.Map
    ( toList )
{- Non-Standard Library Modules Imported -}
{- Local Library Modules Imported -}
import Language.Pepa.Utils
    ( mkCSlist )
import Language.Pepa.Syntax
    ( QualifiedName        ( .. )
    , qualifyQName
    , ParsedComponentId
    , ShowOrig             ( .. )
    , ParsedModel          ( .. )
    , ProcessDef
    , ParsedRate           ( .. )
    , ParsedRateExp        ( .. )
    , ParsedAction         ( .. )
    , RateSpec
    )
import Language.Pepa.Print
    ( HumanPrint ( .. ) )
import Language.Pepa.PepaUtils
    ( Transition 
    , possibleTransSuccessors
    )
import Language.Pepa.Ode.TimedSystemEquation
    ( ConcentrationDB
    , TimedSystem
    , TimedSystemEqn   ( .. )
    , NVFcomp          ( .. )
    )

{- End of Module Imports -}


type RateEqnNumber = Double 
type RateEqnCptType = ParsedComponentId 

type RateEqnInitRate = RateSpec --TimedSystemInitRate
type RateEqnInitComponentConfig = ConcentrationDB

data RateEqnConstDefns = REinitConsts [ RateEqnInitRate ]
                                       RateEqnInitComponentConfig

data RateEqn = REtuple ParsedAction [ RateEqnComponentQuantity ] 
                                     [ RateEqnComponentQuantity ] 
                                     RateEqnRateExpression

data RateEqnComponentQuantity = REcptNum RateEqnNumber RateEqnCptType 
data RateEqnRateExpression =
      RErt ParsedRateExp        -- r, simply a rate
    | RErtCpt RateEqnCptType    -- N(S,t), simply a count. 
                                -- Used when simplifying min(c1*r1,c1*r2) 
    | RErtCptProd RateEqnCptType ParsedRateExp  -- N(S,t) * r,for r, 
                                                -- rate parameter and S,
                                                -- a sequential component 
    | RErtProd RateEqnRateExpression RateEqnRateExpression  
    | RErtMin RateEqnRateExpression RateEqnRateExpression
    | RErtInd RateEqnCptType    -- Indicator function I(a) = 1 if a is true, 
                                -- 0 otherwise, (theta(.) in Dizzy)


data RateEqnModel = REmodel RateEqnConstDefns [RateEqn]



-- Translates a timed system equation model
-- (generated by PepaTimedSystemEquation.hs) to a rate equation model
toRateEqnModel :: ParsedModel -> TimedSystem -> RateEqnModel
toRateEqnModel (ParsedModel _ pDefs _) (rateSpecs, concentrations, tseqn) =
    REmodel reinitconsts res  
    where
    -- We retrieve the initial component configuration fron the timed system equation
    -- and so ensure that component names will be qualified

    --tseeqn should be qualified if called by main in the TSE file
    --   icptl = genTSInitCptConf tseqn  
        
    reinitconsts       = REinitConsts rateSpecs concentrations
        
    res = genREs concentrations tseqn pDefs


-- Generates the rate equations given the timed system equations 
genREs :: RateEqnInitComponentConfig -> TimedSystemEqn 
       -> [ ProcessDef ] -> [ RateEqn ]
genREs icptl (TSECooperation ts1 acts ts2) db = 
    genREsCoop (genREs icptl ts1 db) (genREs icptl ts2 db) acts
--genREs icptl (TSEHide ts acts) db           = 
--    genREsActHide (genREs icptl ts db) acts
--genREs icptl (TSENumVerForm nvflist acts) db  = 
--    genREsNVF icptl nvflist acts db


-- Generates rate equations given two sets of rate equations which cooperate over an action set
genREsCoop :: [ RateEqn ] -> [ RateEqn ] -> [ ParsedAction ] -> [ RateEqn ]
genREsCoop res1 res2 acts = 
    concat [ getREsWhereActNotInList res1 acts
           , getREsWhereActNotInList res2 acts
           , sumREsWithSameAct $ getREsWhereActInList (res1++res2) acts
           ]
    where
    sumREsWithSameAct :: [RateEqn] -> [RateEqn]
    sumREsWithSameAct []  = []
    sumREsWithSameAct res = 
        map (sumSub . (getREsFromAct res)) actslist
        where
        actslist = nub $ getActsFromREs res
        
        sumSub :: [RateEqn] -> RateEqn  
        sumSub ((REtuple a1 s1 s1' r1):((REtuple a2 s2 s2' r2):rs)) =
            if (a1==a2) 
            then sumSub ((REtuple a1 spre spost (RErtMin r1 r2)):rs)
            else -- This error message should never be printed as the parameter 
                 -- passed to sumSub is a list of RateEqn's
                 -- all of which are of the same action
                 error ("PepaRateEquations.genREsCoop.sumREsWithSameAct: Trying "
                 ++ "to sum Rate Equations with different actions")
                 where
                 spre = sumMultiples (s1++s2)
                 spost = sumMultiples (s1'++s2')
        sumSub (a:as) = a
        
{-
-- Generates rate equations given a set of rate equations that we want to perform action hiding for
genREsActHide :: [RateEqn] -> [PEPAacttau] -> [RateEqn]
genREsActHide res acts = (getREsWhereActNotInList res acts) 
            ++ (changeREsToActTau $ getREsWhereActInList res acts)
    where
        changeREsToActTau :: [RateEqn] -> [RateEqn]
        changeREsToActTau [] = []
        changeREsToActTau ((REtuple (PEPAaction a) s1 s2 rate):rs) 
                = (REtuple (PEPAtau a) s1 s2 rate):(changeREsToActTau rs)
-}

-------------------------
--- Functions For NVF ---
-------------------------

{-----------

-- Generates rate equations according to a timed system equation numerical vector form structure.
genREsNVF :: RateEqnInitComponentConfig -> [ NVFcomp ] 
         -> [ ParsedAction ] -> [ ProcessDef ] -> [ RateEqn ]
genREsNVF icptl nvf acts db = 
    (getREsWhereActNotInList nvfres acts)  
    ++ (joinREs icptl (getREsWhereActInList nvfres acts) acts)
    where
    nvfres = foldr1 (++) (map (nvfCptToRE db acts) nvf)


-- Takes an NVF component ie (count, State) and returns all possible rate equations that can
-- be generated from this component. I.e. if A = (a,r1).B + (b,r2).C then we will have two rate equations
-- (a, [A], [B], r1) and (b, [A], [C], r2)
nvfCptToRE :: ParsedModel -> [ ParsedAction ]-> NVFcomp -> [ RateEqn ]
nvfCptToRE model acts (NVFcomp _ qcpt) = 
    mkREsSub tl 
    where 
    cpt = showOrig qcpt
    tl = possibleTransSuccessors cpt model
    i = getQualificationNum qcpt
    getQualificationNum = \(Qualified _ [i]) -> i 
    
    mkREsSub :: Transition -> [ RateEqn ]
    mkREsSub [] = []
    mkREsSub ((cpt1, t, Just cpt2):rs) = 
        if (elem at acts)
            -- For the then case the 1's as the 
            -- 'RateEqnComponentQuantitys' are meaningless,
            -- they are later defined in 
            -- 'getPostState' and 'getPreState'
        then (REtuple at [(REcptNum 1 qcpt1)] 
                         [(REcptNum 1 qcpt2)] 
                         (RErt r))
              :(mkREsSub rs)
        else (REtuple at [(REcptNum 1 qcpt1)] 
                         [(REcptNum 1 qcpt2)] 
                         (RErtCptProd qcpt1 r))
             :(mkREsSub rs) 
             where
             (at, r) = extractFromtrans t
             qcpt1 = qualifyQName cpt1 i
             qcpt2 = qualifyQName cpt2 i
                        
             extractFromtrans = \(a, r) -> (a, r) 


-- Takes a set of rate equations generated from an NVF 
-- and an action set over which the NVF was defined
-- and joins together whichever rate equations possible
joinREs :: RateEqnInitComponentConfig -> [ RateEqn ] 
        -> [ ParsedAction ] -> [ RateEqn ]
joinREs icptl res acts = 
    concat [] -- $ map (joinREsforAct icptl) relistlist
    where
    relistlist = map (getREsFromAct res) acts 
            
---------------}


{-
-- Here, all rate equations passed in the list will be of the same action.
-- Example in comments below    
joinREsforAct :: [RateEqnInitComponentConfig] -> [RateEqn] -> [RateEqn]
joinREsforAct icptl res@((REtuple a _ _ _):rs) = createREtuple a s1 s2 r 
--joinREsforAct icptl res@((REtuple a _ _ _):rs) = if x a then y2 res else createREtuple a s1 s2 r 
    where
-- For Debugging --
--        x = \(PEPAaction x) -> if (x=="a") then True else False
--        y1 = \k1 k2 -> error ("\n\n"++(listToStringListWithNewline k1) ++"\n\n"++ (listToStringListWithNewline k2)  )
--        y2 = \k-> error ("\n\n"++(listToStringListWithNewline k))
-- End For Debugging --
{-
We now define the following terminology for the comment explanations
Rate Equation Pre-Component: The possible RateEqnCptTypes in the RateEqnComponentQuantitys of a rate equation
                             that can evolve
Rate Equation Post-Component: The possible RateEqnCptTypes in the RateEqnComponentQuantitys of a rate equation
                              that the pre-components can evolve into
For example  REtuple a [REcptNum 1 S1] [REcptNum 1 S11] r1 
Here, S1 is a pre-component and S11 is a post-component


Furthermore, to aid in avoidance of confusion, we note that
res here has the following structure
[   REtuple a [(REcptNum 1 S1)] [(REcptNum 1 S11)] r1
    REtuple a [(REcptNum 1 S1)] [(REcptNum 1 S12)] r2
    REtuple a [(REcptNum 1 S2)] [(REcptNum 1 S21)] r1
    REtuple a [(REcptNum 1 S3)] [(REcptNum 1 S31)] r1
    REtuple a [(REcptNum 1 S4)] [(REcptNum 1 S41)] r1
    REtuple a [(REcptNum 1 S4)] [(REcptNum 1 S42)] r1
    ... 
                                                   ]
In other words same action and single RateEqnComponentQuantity
in each pre and post rate equation component 
-}
        nodupres = removeDupREsForPreCpt res
        omegas = genVectors ((genericLength nodupres)::Double) (getDistinctCptInitVal nodupres)
        pis = map (genPis res) omegas       -- pis is of type [[[Double]]]
        s1 = map (getPreState nodupres) omegas  
        s2 = map (getPostState res) pis
        r = map (getRate res) (zip omegas pis)
    
        -- For every w there are many p's, ie for every [Double] there is an [[Double]],
        -- The problem here is what if two dinstinct pre-components have the same post-compoent
        -- for example S1 = (a,l).S3 and S2 = (a,m).S3 . Here the rate equations will look like this
        -- (a [S1] [S3] l) and (a [S2] [S3] m) and hence the genPisSub function will generate pi's of the form
        -- [x,y], ie for 2 post-components. We need another function to adjoin these and generate [x+y]
        -- this function is joinPis 
        genPis :: [RateEqn] -> [Double] -> [[Double]]  
        genPis res w = joinPis $ genPisSub res w
            where
                joinPis :: [[[Double]]] -> [[Double]]
                joinPis (a:[]) = a
                joinPis (a1:(a2:as)) = joinPis ((joinPisSub a1 a2):as) 
                    where
                        joinPisSub :: [[Double]] -> [[Double]] -> [[Double]] 
                        joinPisSub [] _ = []
                        joinPisSub (x:xs) y = (map (x ++) y) ++ (joinPisSub xs y)

                genPisSub :: [RateEqn] -> [Double] -> [[[Double]]]
                genPisSub [] [] = []
                genPisSub  res@((REtuple _ [s] _ _):rs) (wi:wis)
                    = pi : (genPisSub (getREsOtherThanCpt c res) wis)
                    -- Every pi here is a list of lists of Double, [[Double]], and basically corresponds to one
                    -- pre-component. In other words, (genPis res w) is a list of size (length w) =
                    -- the number of distinct pre-components in res
                    where               
                        c = extractCpt s
                        resforc = getREsFromCpt c res
                        pi = genVectors ((genericLength resforc)::Double) wi  


        -- Generates the "pre" states and their coefficiants given a specific omega 
        getPreState :: [RateEqn] -> [Double] -> [RateEqnComponentQuantity]   
        getPreState [] [] = []
        getPreState _ [] = error ("PepaRateEquations.joinREsforAct.getPreState: List sizes"
                ++ " aren't equal (code error 1)")
        getPreState [] _ = error ("PepaRateEquations.joinREsforAct.getPreState: List sizes"
                ++ " aren't equal (code error 2)")
        getPreState ((REtuple _ [(REcptNum _ cpt)] _ _):rs) (x:xs) = (REcptNum x cpt):(getPreState rs xs)



        -- Generates the "post" states and the coefficiants given a specific omega
        -- Remember, this generates one OR MORE rate equation for each omega as a state
        -- can lead to two states (A = B + C), hence the list of lists as a result
        getPostState :: [RateEqn] -> [[Double]] -> [[RateEqnComponentQuantity]]
        getPostState _ [] = []
        getPostState res (pi:pis) = (sumMultiples $ getPostStateSub res pi) : (getPostState res pis)
            where
                -- Given the rate equations that lead out from a specific component and a pi vector
                -- it generates the "post" states
                getPostStateSub :: [RateEqn] -> [Double] -> [RateEqnComponentQuantity]
                getPostStateSub [] [] = []
                getPostStateSub [] _ = error ("PepaRateEquations.joinREsforAct.getPostState: List"
                    ++ " sizes aren't equal (code error 1)")
                getPostStateSub _ [] = error ("PepaRateEquations.joinREsforAct.getPostState: List"
                    ++ " sizes aren't equal (code error 2)")
                getPostStateSub ((REtuple _ _ [(REcptNum _ cpt)] _):rs) (x:xs) 
                    = (REcptNum x cpt):(getPostStateSub rs xs)  
                
        -- Returns a list of rate expressions for our rate equations depending on
        -- a given omega and its pis
        getRate :: [RateEqn] -> ([Double], [[Double]]) -> [RateEqnRateExpression]
        getRate res (w, ps) = map (getRateSub res w) ps where
            getRateSub :: [RateEqn] -> [Double] -> [Double] -> RateEqnRateExpression
            getRateSub res@((REtuple _ [s] _ r):rs) (wi:wis) (pi:pis) = rate
                where
                    c = extractCpt s
                    nextcptcond = isNextPreCptTheSame c rs

                    wis' = if (nextcptcond) then (wi:wis) else wis
                    rate = 
                        if (wi>0 && pi>0)
                        then    if (isThereNextNonZero wis' && isThereNextNonZero pis)
                            then RErtMin r (getRateSub rs wis' pis)
                            else r
                        else    if (isThereNextNonZero wis' && isThereNextNonZero pis)
                            then getRateSub rs wis' pis
                            -- Here we are dealing with a rate equation that has zero counts 
                            -- for all its pre components and post components and hence this 
                            -- equation will not generate a rate equation for our system. 
                            -- Nevertheless, we include it in the list for debugging issues, 
                            -- and define its rate to be 0
                            else RErt $ PEPAreRt $ PEPArt $ Numeric 0 
                    
                    -- Returns true if there is a non zero value in a list of Doubles 
                    isThereNextNonZero :: [Double] -> Bool
                    isThereNextNonZero [] = False
                    isThereNextNonZero (x:xs) 
                        | x>0 = True
                        | x==0 = isThereNextNonZero xs  
                    
                    -- Returns true if the next pre-component in the first rate equation of a list
                    -- is the same as the first argument. False otherwise 
                    isNextPreCptTheSame :: RateEqnCptType -> [RateEqn] -> Bool
                    isNextPreCptTheSame _ [] = False
                    isNextPreCptTheSame cpt ((REtuple _ [s] _ _):rs) = (cpt == extractCpt s)


    
        -- Joins the pre and post states and rates into rate equations
        createREtuple :: PEPAacttau -> [[RateEqnComponentQuantity]] -> [[[RateEqnComponentQuantity]]]
                -> [[RateEqnRateExpression]] -> [RateEqn] 
        createREtuple _ [] _ _ = []
        createREtuple a (s1:s1s) (s2:s2s) (r:rs) = (createREtupleSub a s1 s2 r) ++ (createREtuple a s1s s2s rs)  
            where
                createREtupleSub :: PEPAacttau -> [RateEqnComponentQuantity] -> [[RateEqnComponentQuantity]]
                        -> [RateEqnRateExpression] -> [RateEqn] 
                createREtupleSub _ _ [] [] = []
                createREtupleSub a s1 (s2:s2s) (r:rs) = (REtuple a s1 s2 r):(createREtupleSub a s1 s2s rs)
                createREtupleSub _ _ _ _ = error "PepaRateEquations.joinREsforAct.createREtuple: List sizes aren't equal"
 

        -- Returns the sum of the initial values of each distinct pre-component in a set of rate equations
        getDistinctCptInitVal :: [RateEqn] -> Double
        getDistinctCptInitVal [] = 0
        getDistinctCptInitVal  ((REtuple _ [s] _ _):rs) 
            = (lookupInitCptCount cpt icptl) + getDistinctCptInitVal rs 
                where
                    cpt = extractCpt s

        -- Removes rate equations which have the same pre component as some other one,
        -- i.e. keeps all distinct pre component rate equations
        removeDupREsForPreCpt :: [RateEqn] -> [RateEqn] 
        removeDupREsForPreCpt res = removeDupREsForPreCptSub res []
            where
                removeDupREsForPreCptSub :: [RateEqn] -> [RateEqnCptType] -> [RateEqn]
                removeDupREsForPreCptSub [] _ = []
                removeDupREsForPreCptSub (re@(REtuple _ [s] _ _):rs) visited
                    | elem cpt visited = removeDupREsForPreCptSub rs visited
                    | otherwise = re : (removeDupREsForPreCptSub rs (cpt:visited))
                        where
                            cpt = extractCpt s
        
        -- Given a component and an initial value (count) database returns the corresponding count
        -- for the component
        lookupInitCptCount :: RateEqnCptType -> [RateEqnInitComponentConfig] -> Double
        lookupInitCptCount cpt [] = 1
        lookupInitCptCount cpt ((TScptConf (cpt', n)):icptls) = if (cpt == cpt')
                        then n
                        else lookupInitCptCount cpt icptls

-}
        
-------------------------
--- Utility Functions ---
-------------------------

{- 
    Returns all rates equations whose pre-component 
    (remember, all these should have a single 'RateEqnComponentQuantity'
    in them as explained in 'joinREsforAct') matches an argument
    'RateEqnCptType'
-}
getREsFromCpt :: RateEqnCptType -> [ RateEqn ] -> [ RateEqn ]
getREsFromCpt _ [] = []
getREsFromCpt cpt ((REtuple a [s1] [s2] r):rs) = 
    if (cpt == extractCpt s1)
    then (REtuple a [s1] [s2] r):(getREsFromCpt cpt rs)
    else (getREsFromCpt cpt rs)
 

-- Returns all rates equations whose pre-component (remember, all these should have a single
-- RateEqnComponentQuantity in them as explained in joinREsforAct) do NOT match with an argument RateEqnCptType
getREsOtherThanCpt :: RateEqnCptType -> [ RateEqn ] -> [ RateEqn ]
getREsOtherThanCpt _ [] = []
getREsOtherThanCpt cpt ((REtuple a [s1] [s2] r):rs) = 
    if (cpt /= extractCpt s1)
    then (REtuple a [s1] [s2] r):(getREsOtherThanCpt cpt rs)
    else (getREsOtherThanCpt cpt rs)


--Extracts the component out of a RateEqnComponentQuantity
extractCpt :: RateEqnComponentQuantity -> RateEqnCptType 
extractCpt (REcptNum _ cpt) = cpt 


-- Generates all possible vectors of a given size that have a given norm
-- First argument is vector size, second is sum of elements 
-- for example genVectors 2 10 = [[10,0],[0,10],[9,1],...,[5,5]]
genVectors :: Double -> Double -> [ [ Double ] ]
--genVectors 0 0 = [[]]
genVectors 0 _ = [[]]
genVectors 1 n = [[n]]
genVectors m n = [x:xs | x <- [0..n], xs <- genVectors (m - 1) (n - x) ]


-- Returns all the rate equations whose actions match a given PEPAacttau 
-- argument
getREsFromAct :: [ RateEqn ] -> ParsedAction -> [ RateEqn ]
getREsFromAct [] _ = []
getREsFromAct ((r@(REtuple b _ _ _)):rs) a
    | a == b = r : (getREsFromAct rs a)
    | otherwise = getREsFromAct rs a


-- Returns all the possible PEPAacttau's that a list of rate equations fire
getActsFromREs :: [ RateEqn ] -> [ ParsedAction ]
getActsFromREs [] = []
getActsFromREs ((REtuple a _ _ _):rs) = a : (getActsFromREs rs)
  

-- Returns all the rate equations whose firing action isnt in an argument
-- list of PEPAacttaus
getREsWhereActNotInList :: [ RateEqn ] -> [ ParsedAction ] -> [RateEqn]
getREsWhereActNotInList [] _ = []
getREsWhereActNotInList ((r@(REtuple a _ _ _)):rs) acts
    | elem a acts = getREsWhereActNotInList rs acts
    | otherwise = r : (getREsWhereActNotInList rs acts)


-- Returns all the rate equations whose firing action is in an argument
-- list of PEPAacttaus
getREsWhereActInList :: [ RateEqn ] -> [ ParsedAction ] -> [ RateEqn ]
getREsWhereActInList [] _ = []
getREsWhereActInList ((r@(REtuple a _ _ _)):rs) acts
    | elem a acts = r : (getREsWhereActInList rs acts)
    | otherwise = getREsWhereActInList rs acts
 

-- This function scans through the post-components on our built rate equation
-- and adds together any multiple elements, for example if in [s2] of our rate equation
-- (REtuple a [s1] [s2] r) we find two elements for example (REcptNum a cpt) and
-- (REcptNum b cpt), these will be summed/replaced to/by (REcptNum (a+b) cpt) in [s2]
sumMultiples :: [RateEqnComponentQuantity] -> [RateEqnComponentQuantity]
sumMultiples [] = []
sumMultiples (r@(REcptNum n cpt):recqs) 
    | m == -1 = r : (sumMultiples recqs)
    | otherwise = sumMultiples ((REcptNum (n+k) cpt) : ((take (m-1) recqs)++(drop m recqs)))
        where
            m = findNextSame recqs cpt 1    
            (REcptNum k _) = if (m == -1) then undefined 
                             else recqs !! (m - 1)
            findNextSame :: [RateEqnComponentQuantity] -> RateEqnCptType -> Int -> Int
            findNextSame [] _ _ = -1 -- -1 if there is no more cpt's in the list
            findNextSame ((REcptNum _ cpt):recqs) c n 
                | cpt == c = n
                | otherwise = findNextSame recqs c (n+1)  
                


{-
-- Returns a RateEqnModel who's rate equations have been simplified
simplifyREmodel :: RateEqnModel -> RateEqnModel
simplifyREmodel (REmodel init res) = REmodel init (map simplify res)


-}

-- True if the RateEqnRateExpression is a Top
isRErtTop :: RateEqnRateExpression -> Bool
isRErtTop (RErt RateTop) = True
isRErtTop _              = False




-- Takes an unsimplified model and generates a string for the log file
-- which will contain an unsimplified debbugging version of the rate equation
-- model
analyseREModel :: RateEqnModel -> String
analyseREModel rem = 
    unlines [ "This is the full unsimlpified debugging version of "
            , "This is the full unsimplified version of the"
            , "the Rate Equation Model in Dizzy format:"
            , formatForDizzy rem
            ]


{-
    Formats a rate equation model as output suitable for a .dizzy file.
-}
formatForDizzy :: RateEqnModel -> String
formatForDizzy (REmodel (REinitConsts rateconf cptconf) res) =  
    unlines [ header
            , "//// Initial Rate Configuration" 
            , rateconfForFile
            , "//// Initial Component Configuration"
            , cptconfForFile
            , "//// Rate Equations" 
            , resForFile
            , "//// End File"
            ]
    where
        header = "// Generated by the Imperial College Pepa Compiler\n"
        rateconfForFile = forFileRates rateconf
        cptconfForFile = forFileCptConf cptconf
        -- removeZeroCountElems is called here as so far we do want to see the cpts
        -- that have 0 counts in the rate equation for debugging purposes
        resForFile = forFileRes $ removeZeroCountElems res
        
        forFileRates :: [RateEqnInitRate] -> String
        forFileRates [] = "\n"
        forFileRates ((rlabel, rvalue):rs) 
            = (show rlabel) ++ " = " ++ (show rvalue) ++ ";\n" ++ (forFileRates rs)

        forFileCptConf :: RateEqnInitComponentConfig -> String
        forFileCptConf = 
            unlines . (map formatForDizzyREICC) . toList
            where
            formatForDizzyREICC :: (ParsedComponentId, Int) -> String
            formatForDizzyREICC (c, n) =
                unwords [ show c
                        , "="
                        , show n
                        ]

        --Hmm this could be tidied up somewhat.
        forFileRes :: [RateEqn] -> String
        forFileRes res = forFileResSub res 1 where
            forFileResSub :: [RateEqn] -> Int -> String
            forFileResSub [] _ = "\n"
            forFileResSub ((REtuple a s1 s2 r):res) i =
                concat [ formatDizzyAction a
                       , show i
                       , ",\n"
                       , "\t"
                       , showFileRecqs s1
                       , " ->\n"
                       , "\t"
                       , showFileRecqs s2
                       , ", [ "
                       , formatDizzyRateExpr r
                       , " ];\n\n"
                       , forFileResSub res (i + 1)
                       ]
                where
                    showFileRecqs :: [RateEqnComponentQuantity] -> String
                    showFileRecqs [] = ""
                    showFileRecqs ((REcptNum n cpt):recqs)
                          = (showRecursive n cpt)
                          ++ (if (null recqs) then "" else " + ")
                          ++ (showFileRecqs recqs)
                    
                    showRecursive :: Double -> RateEqnCptType -> String
                    showRecursive 0 _ = ""
                    showRecursive 1 cpt = show cpt
                    showRecursive n cpt = (show cpt) ++
                        " + " ++ (showRecursive (n-1) cpt)

formatDizzyAction :: ParsedAction -> String
formatDizzyAction (Action ident) = show ident
formatDizzyAction (Tau ident)    = '\'' : (show ident)


{-
instance Show RateEqnModel where
    show (REmodel (REinitConsts rates cpts) res) = (unlines ["\nRate Equation Model","-------------------"]) ++
                 ("Initial Component Configuration:\n") ++
                 (listToStringListWithNewline cpts) ++
                 ("\n\nInitial Rate Configuration:\n") ++
                 (listToStringListWithNewline rates) ++
                 ("\n\nRate Equations:\n") ++
                 (listToStringListWithNewline res) ++
                "\n\n-------------------\n" ++ 
                 "End Rate Equation Model\n"
-}



formatDizzyRateEqn :: RateEqn -> String
formatDizzyRateEqn (REtuple a s1 s2 rate) =
    concat [ "("
           , formatDizzyAction a
           , ", {"
           , mkCSlist $ map formatDizzyRateQuantity s1
           , "}, {"
           , mkCSlist $ map formatDizzyRateQuantity s2
           , "}, "
           , formatDizzyRateExpr rate
           ]

formatDizzyRateExpr :: RateEqnRateExpression -> String
formatDizzyRateExpr (RErt r)              = 
    formatRateExprForDizzy r
formatDizzyRateExpr (RErtCpt c)           = 
    show c
formatDizzyRateExpr (RErtCptProd ident r) = 
    unwords [ show ident, "*", formatRateExprForDizzy r ]
formatDizzyRateExpr (RErtProd r1 r2)      =
    unwords [ formatDizzyRateExpr r1, "*", formatDizzyRateExpr r2 ]
formatDizzyRateExpr (RErtMin a b)         =
    unwords [ "min("
            , formatDizzyRateExpr a
            , ","
            , formatDizzyRateExpr b
            , ")"
            ]
formatDizzyRateExpr (RErtInd x)           =
    unwords [ "theta("
            , show x
            , ")"
            ]


formatRateExprForDizzy :: ParsedRateExp -> String
formatRateExprForDizzy = hprint

formatDizzyRateQuantity :: RateEqnComponentQuantity -> String
formatDizzyRateQuantity (REcptNum n ident) =
    concat [ "("
           , show n
           , ", "
           , show ident
           , ")"
           ]


-- Removes the RateEqnComponentQuantitys that have count 0 from a 
-- set of rate equations
-- ex REtuple a [(REcptNum 0.0 "P1"), (REcptNum 1.0 "P2)] [...] rate
-- will become REtuple [(REcptNum 1.0 "P2)] [...] rate 
-- Note that the 0 count component removal is performed on both
-- the pre-components and the post-components
removeZeroCountElems :: [ RateEqn ] -> [ RateEqn ]
removeZeroCountElems res = foldr1 (++) (filter nonEmpty (map handleRE res))
    where
        nonEmpty = not . null
        handleRE (REtuple a s1 s2 r) =
            let
                isCountNonZero (REcptNum n c) = (n/=0)
                s1' = filter isCountNonZero s1
                s2' = filter isCountNonZero s2
            in
              [ REtuple a sl' s2' r | nonEmpty s1' && nonEmpty s2' ]

